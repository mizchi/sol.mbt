{
  "version": 3,
  "sources": ["../../../js/sol/signal.ts", "../../../js/sol/hydration.ts", "../app/client/counter.ts", "../app/client/entry.ts"],
  "sourcesContent": ["/**\n * Simple reactive signal system for client-side Luna\n * Minimal implementation for island hydration\n */\n\ntype Listener = () => void;\nlet currentListener: Listener | null = null;\n\nexport type Accessor<T> = () => T;\nexport type Setter<T> = (value: T | ((prev: T) => T)) => void;\nexport type Signal<T> = [Accessor<T>, Setter<T>];\n\n/**\n * Creates a reactive signal\n */\nexport function createSignal<T>(initialValue: T): Signal<T> {\n  let value = initialValue;\n  const listeners = new Set<Listener>();\n\n  const getter: Accessor<T> = () => {\n    if (currentListener) {\n      listeners.add(currentListener);\n    }\n    return value;\n  };\n\n  const setter: Setter<T> = (newValue) => {\n    const nextValue = typeof newValue === 'function'\n      ? (newValue as (prev: T) => T)(value)\n      : newValue;\n\n    if (nextValue !== value) {\n      value = nextValue;\n      for (const listener of listeners) {\n        listener();\n      }\n    }\n  };\n\n  return [getter, setter];\n}\n\n/**\n * Creates a reactive effect\n */\nexport function createEffect(fn: () => void): void {\n  const execute = () => {\n    currentListener = execute;\n    try {\n      fn();\n    } finally {\n      currentListener = null;\n    }\n  };\n  execute();\n}\n\n/**\n * Creates a memoized computed value\n */\nexport function createMemo<T>(fn: () => T): Accessor<T> {\n  const [value, setValue] = createSignal<T>(undefined as T);\n\n  createEffect(() => {\n    setValue(fn());\n  });\n\n  return value;\n}\n\n/**\n * Batch multiple updates\n */\nlet batchDepth = 0;\nlet pendingUpdates: Set<Listener> = new Set();\n\nexport function batch(fn: () => void): void {\n  batchDepth++;\n  try {\n    fn();\n  } finally {\n    batchDepth--;\n    if (batchDepth === 0) {\n      const updates = pendingUpdates;\n      pendingUpdates = new Set();\n      for (const update of updates) {\n        update();\n      }\n    }\n  }\n}\n", "/**\n * Hydration utilities for Luna islands\n */\n\nexport type HydrateFn = (\n  element: Element,\n  state: unknown,\n  name: string\n) => void | (() => void);\n\nexport type CleanupFn = () => void;\n\n/**\n * Create a hydration function with automatic guards\n *\n * @example\n * ```ts\n * export const hydrate = createHydrator((el, state) => {\n *   // Your hydration logic here\n *   render(() => <Counter {...state} />, el);\n *\n *   // Optional: return cleanup function\n *   return () => { ... };\n * });\n * ```\n */\nexport function createHydrator(\n  fn: (element: Element, state: unknown, name: string) => void | CleanupFn\n): HydrateFn {\n  // Store cleanup functions by element\n  const cleanups = new WeakMap<Element, CleanupFn>();\n\n  return (element: Element, state: unknown, name: string): void => {\n    // Skip if already hydrated\n    if ((element as HTMLElement).dataset.hydrated) {\n      return;\n    }\n\n    // Run cleanup if re-hydrating (HMR scenario)\n    const existingCleanup = cleanups.get(element);\n    if (existingCleanup) {\n      existingCleanup();\n      cleanups.delete(element);\n    }\n\n    // Run hydration\n    const cleanup = fn(element, state, name);\n\n    // Store cleanup if provided\n    if (typeof cleanup === 'function') {\n      cleanups.set(element, cleanup);\n    }\n\n    // Mark as hydrated\n    (element as HTMLElement).dataset.hydrated = 'true';\n  };\n}\n", "// Counter Client Component\n// Uses Luna's reactive system for client-side interactivity\n\nimport { createSignal, createEffect, createHydrator } from '@luna_ui/luna';\n\ninterface CounterProps {\n  initialCount: number;\n}\n\n// Hydration function for island architecture\nexport const hydrate = createHydrator((element, state) => {\n  const props = state as CounterProps;\n  const [count, setCount] = createSignal(props.initialCount);\n\n  // Find elements\n  const display = element.querySelector('.count-display') as HTMLElement;\n  const decButton = element.querySelector('.dec') as HTMLButtonElement;\n  const incButton = element.querySelector('.inc') as HTMLButtonElement;\n\n  if (!display || !decButton || !incButton) {\n    console.error('Counter: Missing required elements');\n    return;\n  }\n\n  // Update display when count changes\n  createEffect(() => {\n    display.textContent = String(count());\n  });\n\n  // Event handlers\n  decButton.addEventListener('click', () => setCount((n) => n - 1));\n  incButton.addEventListener('click', () => setCount((n) => n + 1));\n\n  // Cleanup\n  return () => {\n    decButton.removeEventListener('click', () => {});\n    incButton.removeEventListener('click', () => {});\n  };\n});\n", "// Client Entry Point\n// Registers all island hydrators and runs hydration on page load\n\nimport { hydrate as counterHydrate } from './counter.js';\n\n// Island registry\nconst islands: Record<string, (el: Element, state: unknown, name: string) => void> = {\n  counter: counterHydrate,\n};\n\n// Hydrate all islands on the page\nfunction hydrateAll() {\n  const islandElements = document.querySelectorAll('[data-island]');\n\n  for (const element of islandElements) {\n    const name = (element as HTMLElement).dataset.island;\n    if (!name) continue;\n\n    const hydrator = islands[name];\n    if (!hydrator) {\n      console.warn(`Unknown island: ${name}`);\n      continue;\n    }\n\n    // Parse state from data-state attribute\n    const stateStr = (element as HTMLElement).dataset.state;\n    let state: unknown = {};\n    if (stateStr) {\n      try {\n        state = JSON.parse(stateStr);\n      } catch (e) {\n        console.error(`Failed to parse state for island ${name}:`, e);\n      }\n    }\n\n    hydrator(element, state, name);\n  }\n}\n\n// Run hydration when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', hydrateAll);\n} else {\n  hydrateAll();\n}\n"],
  "mappings": "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",
  "names": []
}
