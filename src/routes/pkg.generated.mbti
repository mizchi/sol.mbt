// Generated using `moon info`, DON'T EDIT IT
package "mizchi/luna/sol/routes"

import(
  "mizchi/luna/luna"
  "mizchi/luna/sol/content/frontmatter"
  "mizchi/luna/sol/core/env"
  "mizchi/luna/sol/ssg"
)

// Values
pub fn build_chunk_manifest(RouteManifest, chunk_files? : Array[(String, String)], base? : String) -> ChunkManifest

pub fn build_static_paths(String, Array[Map[String, String]]) -> Array[StaticPathEntry]

pub fn check_duplicate_pages(Array[@ssg.PageMeta]) -> Array[DuplicatePage]

pub fn detect_component_type(Bool, Bool) -> ComponentType

pub fn detect_conflicts(RouteManifest) -> Array[ConflictType]

pub fn determine_renderer_type(@ssg.ContentType, @frontmatter.Frontmatter) -> @ssg.RendererType

pub fn extract_catch_all(String) -> CatchAllInfo?

pub fn extract_first_segment(String) -> String

pub fn extract_param_from_filename(String) -> ParamInfo?

pub fn extract_param_name(String) -> ParamInfo?

pub fn extract_url_pattern(String) -> (String, Array[String])

pub fn file_to_url_path(String, trailing_slash? : Bool) -> String

pub fn filter_by_mode(RouteManifest, RenderMode) -> RouteManifest

pub fn find_fallback_page(Array[@ssg.PageMeta], String, @ssg.I18nConfig) -> @ssg.PageMeta?

pub fn find_last_char(String, Char) -> Int

pub fn find_next_page(Array[@ssg.PageMeta], String) -> @frontmatter.NavLink?

pub fn find_prev_page(Array[@ssg.PageMeta], String) -> @frontmatter.NavLink?

pub fn find_route(RouteManifest, String) -> RouteEntry?

pub fn find_segment_ref(HierarchicalManifest, String) -> (String, SegmentRef)?

pub fn find_static_route(RouteManifest, String) -> StaticRouteEntry?

pub fn find_translation(Array[@ssg.PageMeta], String, String) -> @ssg.PageMeta?

pub fn format_duplicate_error(DuplicatePage) -> String

pub fn generate_auto_sidebar(Array[@ssg.PageMeta], locale? : String) -> Array[@ssg.SidebarGroup]

pub fn get_all_segments(RouteManifest) -> Array[String]

pub fn get_api_routes(RouteManifest) -> Array[ApiRouteEntry]

pub fn get_available_translations(Array[@ssg.PageMeta], String, @ssg.I18nConfig) -> Array[(@ssg.LocaleConfig, @ssg.PageMeta?)]

pub fn get_basename(String) -> String

pub fn get_dynamic_routes(RouteManifest) -> Array[DynamicRouteEntry]

pub fn get_extension(String) -> String

pub fn get_pages_for_locale(Array[@ssg.PageMeta], String) -> Array[@ssg.PageMeta]

pub fn get_parent_dir(String) -> String

pub fn get_parent_path(String) -> String

pub fn get_route_path(RouteEntry) -> String

pub fn get_sidebar_for_path(@ssg.SsgConfig, Array[@ssg.PageMeta], String, locale? : String) -> Array[@ssg.SidebarGroup]

pub fn get_sidebar_page_order(Array[@ssg.SidebarGroup]) -> Array[String]

pub fn get_static_routes(RouteManifest) -> Array[StaticRouteEntry]

pub fn group_pages_by_dir(Array[@ssg.PageMeta]) -> Map[String, Array[@ssg.PageMeta]]

pub fn is_content_file(String) -> Bool

pub fn is_excluded(String, String, Array[String]) -> Bool

pub fn is_moonbit_component(String) -> Bool

pub fn is_param_char(Char) -> Bool

pub fn is_tsx_file(String) -> Bool

pub fn join_path(String, String) -> String

pub fn manifest_to_page_metas(RouteManifest) -> Array[@ssg.PageMeta]

pub fn match_dynamic_pattern(SegmentManifest, String) -> (DynamicPattern, Map[String, String])?

pub fn merge_all_manifests(Array[RouteManifest]) -> RouteManifest

pub fn merge_manifests(RouteManifest, RouteManifest) -> RouteManifest

pub fn normalize_url_path(String) -> String

pub fn page_meta_to_static_route(@ssg.PageMeta) -> StaticRouteEntry

pub fn page_metas_to_manifest(Array[@ssg.PageMeta], @ssg.SsgConfig) -> RouteManifest

pub fn parse_bracket_param(String, Int) -> (Int, String, Bool)

pub fn parse_page_config(String) -> PageConfig?

pub fn path_matches_segment(String, String) -> Bool

pub fn render_mobile_sidebar(Array[@ssg.SidebarGroup], String) -> @luna.Node[Unit]

pub fn render_sidebar(Array[@ssg.SidebarGroup], String) -> @luna.Node[Unit]

pub fn resolve_chunks_inline(HierarchicalManifest, String) -> Array[String]?

pub fn resolve_duplicate_pages(Array[@ssg.PageMeta]) -> (Array[@ssg.PageMeta], Array[DuplicatePage])

pub fn route_manifest_to_chunk_manifest(RouteManifest, chunk_hashes? : Map[String, String]) -> ChunkManifest

pub fn safe_char_at(String, Int) -> Char

pub fn safe_substring(String, Int, Int) -> String

pub fn[FS : @env.FileSystem] scan_directory(FS, String, ScanOptions) -> Array[FileEntry]

pub fn scan_docs_dir(String, String, i18n? : @ssg.I18nConfig, exclude? : Array[String], trailing_slash? : Bool) -> Array[@ssg.PageMeta]

pub fn[FS : @env.FileSystem] scan_docs_dir_with_fs(FS, String, String, i18n? : @ssg.I18nConfig, exclude? : Array[String], trailing_slash? : Bool) -> Array[@ssg.PageMeta]

pub fn[FS : @env.FileSystem] scan_pages_dir(FS, String, String) -> RouteManifest

pub fn sort_pages(Array[@ssg.PageMeta]) -> Array[@ssg.PageMeta]

pub fn split_manifest(RouteManifest, Map[String, PageConfig]) -> (HierarchicalManifest, Map[String, SegmentManifest])

pub fn static_route_to_page_meta(StaticRouteEntry) -> @ssg.PageMeta

pub fn url_to_output_path(String) -> String

// Errors

// Types and methods
pub(all) struct ApiRouteEntry {
  path : String
  pattern : String
  param_names : Array[String]
  http_method : HttpMethod
  source : String
}
pub fn ApiRouteEntry::new(path~ : String, pattern~ : String, http_method~ : HttpMethod, source~ : String) -> Self

pub(all) struct CatchAllInfo {
  name : String
  optional : Bool
}

pub(all) struct ChunkManifest {
  routes : Map[String, Array[String]]
  chunks : Map[String, String]
  base : String
}
pub fn ChunkManifest::empty() -> Self
pub fn ChunkManifest::new(base? : String) -> Self
pub fn ChunkManifest::to_json(Self) -> String

pub(all) struct ComponentConfig {
  ssr : Bool
  props_type : String?
  client_export : String?
  server_export : String?
}
pub fn ComponentConfig::default() -> Self

pub(all) struct ComponentRouteEntry {
  path : String
  source : String
  component_type : ComponentType
  mode : RenderMode
  layout : String?
  props_type : String?
  client_export : String?
  server_export : String?
  static_paths : Array[StaticPathEntry]
  islands : Array[String]
}
pub fn ComponentRouteEntry::new(path~ : String, source~ : String, component_type~ : ComponentType, mode~ : RenderMode) -> Self

pub(all) enum ComponentType {
  SsrComponent
  ClientOnlyComponent
  ServerOnlyComponent
}
pub fn ComponentType::can_hydrate(Self) -> Bool
pub fn ComponentType::can_ssr(Self) -> Bool
pub impl Show for ComponentType

pub(all) enum ConflictType {
  DuplicatePath(path~ : String, sources~ : Array[String])
  StaticShadowsDynamic(static_path~ : String, dynamic_pattern~ : String)
  MultipleCatchAll(paths~ : Array[String])
  AmbiguousDynamic(pattern1~ : String, pattern2~ : String)
}
pub fn ConflictType::is_error(Self) -> Bool
pub fn ConflictType::to_string(Self) -> String

pub(all) struct DuplicatePage {
  url_path : String
  sources : Array[String]
}

pub(all) struct DynamicPattern {
  pattern : String
  regex : String
  params : Array[String]
  catch_all : Bool
}
pub fn DynamicPattern::new(pattern~ : String, regex~ : String, params~ : Array[String], catch_all? : Bool) -> Self
pub fn DynamicPattern::to_json(Self) -> String

pub(all) struct DynamicRouteEntry {
  path : String
  pattern : String
  param_names : Array[String]
  source : String
  mode : RenderMode
  layout : String?
  catch_all : CatchAllInfo?
  title : String?
  islands : Array[String]
}
pub fn DynamicRouteEntry::new(path~ : String, pattern~ : String, param_names~ : Array[String], source~ : String, mode~ : RenderMode) -> Self

pub(all) enum FallbackConfig {
  NotFound(path~ : String)
  Spa(entry~ : String)
  SpaPrefix(prefix~ : String, entry~ : String)
}
pub fn FallbackConfig::default() -> Self
pub fn FallbackConfig::is_spa(Self) -> Bool
pub fn FallbackConfig::spa_entry(Self) -> String?
pub impl Eq for FallbackConfig
pub impl Show for FallbackConfig

pub(all) struct FileEntry {
  relative_path : String
  absolute_path : String
  extension : String
  is_directory : Bool
}

pub(all) struct FileHandlerConfig {
  layout : String?
  islands : Array[String]
  passthrough : Bool
}
pub fn FileHandlerConfig::default() -> Self

pub(all) enum FileType {
  MoonBit
  Markdown
  Mdx
  Html
  Unknown
}
pub fn FileType::from_extension(String) -> Self
pub fn FileType::is_page(Self) -> Bool
pub impl Eq for FileType
pub impl Show for FileType

pub(all) struct HierarchicalManifest {
  version : Int
  base : String
  segments : Map[String, SegmentRef]
  chunks : Map[String, String]
  routes : Map[String, Array[String]]
}
pub fn HierarchicalManifest::empty() -> Self
pub fn HierarchicalManifest::new(base? : String) -> Self
pub fn HierarchicalManifest::to_json(Self) -> String

pub(all) enum HttpMethod {
  Get
  Post
  Put
  Delete
  Patch
  All
}
pub fn HttpMethod::from_string(String) -> Self?
pub fn HttpMethod::to_string(Self) -> String
pub impl Eq for HttpMethod
pub impl Show for HttpMethod

pub(all) struct PageConfig {
  mode : String?
  revalidate : Int?
  title : String?
  description : String?
  layout : String?
  islands : Array[String]
  generate_params : Bool
  static_params : Array[Map[String, String]]
  fallback : Bool
  spa : Bool
  fallback_behavior : String?
  extends : String?
  handlers : Map[String, FileHandlerConfig]
  component : ComponentConfig?
}
pub fn PageConfig::default() -> Self
pub fn PageConfig::has_static_params(Self) -> Bool
pub fn PageConfig::is_component(Self) -> Bool
pub fn PageConfig::is_dynamic(Self) -> Bool
pub fn PageConfig::is_isr(Self) -> Bool
pub fn PageConfig::is_spa(Self) -> Bool
pub fn PageConfig::is_static(Self) -> Bool
pub fn PageConfig::merge(Self, Self) -> Self
pub fn PageConfig::to_render_mode(Self) -> RenderMode

pub(all) struct ParamInfo {
  name : String
  catch_all : Bool
}

pub(all) enum RenderMode {
  Ssr
  Isr(revalidate~ : Int)
  Spa
}
pub fn RenderMode::default() -> Self
pub fn RenderMode::requires_server(Self) -> Bool
pub fn RenderMode::revalidate_seconds(Self) -> Int?
pub impl Eq for RenderMode
pub impl Show for RenderMode

pub(all) enum RouteEntry {
  Static(StaticRouteEntry)
  Dynamic(DynamicRouteEntry)
  Api(ApiRouteEntry)
  Component(ComponentRouteEntry)
}
pub fn RouteEntry::is_api(Self) -> Bool
pub fn RouteEntry::is_component(Self) -> Bool
pub fn RouteEntry::is_dynamic(Self) -> Bool
pub fn RouteEntry::is_static(Self) -> Bool
pub fn RouteEntry::path(Self) -> String
pub fn RouteEntry::source(Self) -> String

pub(all) struct RouteManifest {
  routes : Array[RouteEntry]
  fallback : FallbackConfig
}
pub fn RouteManifest::empty() -> Self

pub(all) struct ScanOptions {
  exclude : Array[String]
  trailing_slash : Bool
}
pub fn ScanOptions::default() -> Self

pub(all) struct SegmentManifest {
  base : String
  routes : Map[String, Array[String]]
  dynamic : Array[DynamicPattern]
  fallback : String
}
pub fn SegmentManifest::empty(String) -> Self
pub fn SegmentManifest::to_json(Self) -> String

pub(all) struct SegmentRef {
  path : String
  pattern : String
  spa : Bool
  preload : Bool
}
pub fn SegmentRef::new(path~ : String, pattern~ : String, spa? : Bool, preload? : Bool) -> Self
pub fn SegmentRef::to_json(Self) -> String

pub(all) struct StaticPathEntry {
  params : Map[String, String]
  output : String
}
pub fn StaticPathEntry::new(params~ : Map[String, String], output~ : String) -> Self

pub(all) struct StaticRouteEntry {
  path : String
  source : String
  output : String
  layout : String?
  title : String?
  description : String?
  islands : Array[String]
  locale : String
  generated_params : Array[Map[String, String]]
}
pub fn StaticRouteEntry::new(path~ : String, source~ : String, output~ : String) -> Self

// Type aliases

// Traits

