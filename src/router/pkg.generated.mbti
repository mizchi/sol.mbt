// Generated using `moon info`, DON'T EDIT IT
package "mizchi/luna/sol/router"

import(
  "mizchi/js/core"
  "mizchi/js/web/http"
  "mizchi/js/web/url"
  "mizchi/luna/luna"
  "mizchi/luna/luna/static_dom"
  "mizchi/luna/sol/isr"
  "mizchi/luna/sol/middleware"
  "mizchi/luna/sol/ssg"
  "mizchi/npm_typed/hono"
)

// Values
pub fn analyze_routes(Array[SolRoutes]) -> Array[AnalyzedRoute]

pub fn api_get(String, async (PageProps) -> @core.Any) -> SolRoutes

pub fn api_post(String, async (PageProps) -> @core.Any) -> SolRoutes

pub fn bad_request(String) -> ApiResponse

pub fn combine_api_factories(Array[ApiHandlerFactory]) -> ApiHandlerFactory

pub fn combine_page_factories(Array[PageHandlerFactory]) -> PageHandlerFactory

pub fn compile_sol_routes(Array[SolRoutes], base? : String) -> Array[CompiledSolRoute]

pub fn default_root_template() -> String

pub fn error_response(String, status? : Int) -> ApiResponse

pub fn extract_dynamic_patterns(Array[SolRoutes]) -> Array[String]

pub fn forbidden(message? : String) -> ApiResponse

pub fn generate_wrangler_assets_config(Array[SolRoutes], String) -> String

pub fn has_fragment_header(@hono.Context[Unit, Unit]) -> Bool

pub fn manifest_to_sol_routes(@mizchi/luna/sol/routes.RouteManifest, PageHandlerFactory, ApiHandlerFactory) -> Array[SolRoutes]

pub fn nodes(Array[@luna.Node[Unit]]) -> @static_dom.ServerNode

pub fn not_found_response(message? : String) -> ApiResponse

pub fn null_api_factory() -> ApiHandlerFactory

pub fn null_page_factory() -> PageHandlerFactory

pub fn ok(Array[(String, @core.Any)]) -> ApiResponse

pub fn optional(PageProps, String, String) -> String

pub fn optional_query(PageProps, String, String) -> String

pub fn page(String, async (PageProps) -> @static_dom.ServerNode, title? : String, meta? : Array[(String, String)], revalidate? : Int?, cache? : CacheStrategy?) -> SolRoutes

pub fn redirect_permanent_to(String) -> ApiResponse

pub fn redirect_to(String, status? : Int) -> ApiResponse

pub fn[E] register_routes(@hono.Hono[Unit, Unit], Array[@mizchi/luna/luna/routes.Routes], (String, @hono.Context[Unit, Unit], RouteParams) -> @luna.Node[E]?, (String, @hono.Context[Unit, Unit], RouteParams) -> @core.Any?, config? : RouterConfig, title_prefix? : String, default_title? : String, default_head? : String, loader_url? : String, wc_loader_url? : String) -> @hono.Hono[Unit, Unit]

pub fn register_server_routes(@hono.Hono[Unit, Unit], Array[@mizchi/luna/luna/routes.Routes], (String, @hono.Context[Unit, Unit], RouteParams) -> @static_dom.ServerNode?, (String, @hono.Context[Unit, Unit], RouteParams) -> @core.Any?, config? : RouterConfig, title_prefix? : String, default_title? : String, default_head? : String, loader_url? : String, wc_loader_url? : String) -> @hono.Hono[Unit, Unit]

pub fn register_sol_routes(@hono.Hono[Unit, Unit], Array[SolRoutes], config? : RouterConfig) -> @hono.Hono[Unit, Unit]

pub fn[E] render_fragment_response(@luna.Node[E], String, Bool) -> String

pub fn require(PageProps, String) -> Result[String, ApiResponse]

pub fn require_int(PageProps, String) -> Result[Int, ApiResponse]

pub fn require_query(PageProps, String) -> Result[String, ApiResponse]

pub fn send_fragment_response(@hono.Context[Unit, Unit], String) -> @http.Response

pub fn sol_routes_to_manifest(Array[SolRoutes], base? : String) -> @mizchi/luna/sol/routes.RouteManifest

pub fn unauthorized(message? : String) -> ApiResponse

pub fn with_mw(Array[@middleware.Middleware], Array[SolRoutes]) -> SolRoutes

pub fn wrap(String, (PageProps, @static_dom.ServerNode) -> @static_dom.ServerNode raise, Array[SolRoutes]) -> SolRoutes

// Errors

// Types and methods
pub(all) struct AnalyzedRoute {
  pattern : String
  kind : RouteKind
  reason : String
}

pub(all) struct ApiHandler(async (PageProps) -> @core.Any)
#deprecated
pub fn ApiHandler::inner(Self) -> async (PageProps) -> @core.Any

pub(all) struct ApiHandlerFactory((@mizchi/luna/sol/routes.RouteEntry) -> ApiHandler?)
#deprecated
pub fn ApiHandlerFactory::inner(Self) -> (@mizchi/luna/sol/routes.RouteEntry) -> ApiHandler?

pub(all) enum ApiResponse {
  Json(@core.Any)
  Redirect(String, Int)
  NotFound(String)
  Error(String, Int)
}
pub fn ApiResponse::to_json(Self) -> @core.Any

pub(all) enum CacheStrategy {
  AlwaysFetch
  StaleWhileRevalidate
}
pub fn CacheStrategy::default() -> Self
pub impl Eq for CacheStrategy
pub impl Show for CacheStrategy

pub(all) struct CatchAllInfo {
  name : String
  optional : Bool
}

pub struct ChunkManifest {
  entries : Map[String, ChunkManifestEntry]
  base_url : String
}
pub fn ChunkManifest::add(Self, String, ChunkManifestEntry) -> Unit
pub fn ChunkManifest::empty() -> Self
pub fn ChunkManifest::get_chunks(Self, String) -> Array[String]
pub fn ChunkManifest::new(String) -> Self
pub fn ChunkManifest::parse(String, String) -> Self?

pub struct ChunkManifestEntry {
  file : String
  imports : Array[String]
}
pub fn ChunkManifestEntry::new(String, Array[String]) -> Self

pub struct CompiledSolRoute {
  pattern : String
  param_names : Array[String]
  page_handler : PageHandler?
  api_handler : ApiHandler?
  layouts : Array[(PageProps, @static_dom.ServerNode) -> @static_dom.ServerNode raise]
  middlewares : Array[@middleware.Middleware]
  kind : SolRouteKind
  title : String
  meta : Array[(String, String)]
  catch_all : CatchAllInfo?
  revalidate : Int?
  cache_strategy : CacheStrategy
}

pub(all) struct PageHandler(async (PageProps) -> @static_dom.ServerNode)
#deprecated
pub fn PageHandler::inner(Self) -> async (PageProps) -> @static_dom.ServerNode

pub(all) struct PageHandlerFactory((@mizchi/luna/sol/routes.RouteEntry) -> PageHandler?)
#deprecated
pub fn PageHandlerFactory::inner(Self) -> (@mizchi/luna/sol/routes.RouteEntry) -> PageHandler?

pub struct PageProps {
  ctx : @hono.Context[Unit, Unit]
  params : RouteParams
  is_fragment : Bool
}
pub fn PageProps::from_ctx(@hono.Context[Unit, Unit]) -> Self
pub fn PageProps::from_ctx_fragment(@hono.Context[Unit, Unit]) -> Self
pub fn PageProps::from_ctx_with_params(@hono.Context[Unit, Unit], RouteParams) -> Self
pub fn PageProps::get_param(Self, String) -> String?
pub fn PageProps::get_pathname_group(Self, String) -> String?
pub fn PageProps::get_query(Self, String) -> String?
pub fn PageProps::get_search_group(Self, String) -> String?
pub fn PageProps::path(Self) -> String

pub(all) enum RouteKind {
  Static
  Dynamic
}

pub struct RouteParams {
  params : Array[(String, String)]
  query : Array[(String, String)]
  path : String
  is_fragment : Bool
  url_pattern_result : @url.URLPatternResult?
}
pub fn RouteParams::empty() -> Self
pub fn RouteParams::get_param(Self, String) -> String?
pub fn RouteParams::get_pathname_group(Self, String) -> String?
pub fn RouteParams::get_query(Self, String) -> String?
pub fn RouteParams::get_search_group(Self, String) -> String?

pub struct RouterConfig {
  title_prefix : String
  default_title : String
  default_head : String
  loader_url : String
  wc_loader_url : String
  enable_preload : Bool
  preload_libs : Array[String]
  chunk_manifest : ChunkManifest?
  root_template : String
  isr_cache : @isr.MemoryCache?
}
pub fn RouterConfig::default() -> Self
pub fn RouterConfig::with_chunk_manifest(Self, ChunkManifest) -> Self
pub fn RouterConfig::with_default_head(Self, String) -> Self
pub fn RouterConfig::with_default_title(Self, String) -> Self
pub fn RouterConfig::with_isr_cache(Self, @isr.MemoryCache) -> Self
pub fn RouterConfig::with_loader_url(Self, String) -> Self
pub fn RouterConfig::with_preload_libs(Self, Array[String]) -> Self
pub fn RouterConfig::with_root_template(Self, String) -> Self
pub fn RouterConfig::with_title_prefix(Self, String) -> Self
pub fn RouterConfig::with_wc_loader_url(Self, String) -> Self

pub enum SolRouteKind {
  Page
  GetApi
  PostApi
}
pub impl Eq for SolRouteKind
pub impl Show for SolRouteKind

pub(all) enum SolRoutes {
  Page(path~ : String, handler~ : PageHandler, title~ : String, meta~ : Array[(String, String)], revalidate~ : Int?, cache~ : CacheStrategy?)
  Layout(segment~ : String, layout~ : (PageProps, @static_dom.ServerNode) -> @static_dom.ServerNode raise, children~ : Array[SolRoutes])
  Get(path~ : String, handler~ : ApiHandler)
  Post(path~ : String, handler~ : ApiHandler)
  WithMiddleware(middleware~ : Array[@middleware.Middleware], children~ : Array[SolRoutes])
}

pub(all) struct StaticDir {
  path_prefix : String
  source_dir : String
  title : String
  config : StaticDirConfig
}

pub(all) struct StaticDirConfig {
  i18n : @ssg.I18nConfig
  navigation : @ssg.NavigationConfig
  exclude : Array[String]
  trailing_slash : Bool
}
pub fn StaticDirConfig::default() -> Self

// Type aliases
pub type App = @hono.Hono[Unit, Unit]

pub type AsyncPageResolver = (String, @hono.Context[Unit, Unit], RouteParams) -> @static_dom.ServerNode?

pub type Ctx = @hono.Context[Unit, Unit]

pub type Env = Unit

pub type ExecutionContext = Unit

// Traits

