// MBTI Parser
//
// Extracts public function signatures and struct definitions from .mbti files.
// MBTI files are generated by `moon info` and contain type interface information.

// =============================================================================
// Types
// =============================================================================

///|
/// Represents a public function extracted from mbti
pub(all) struct PubFunc {
  name : String
  type_name : String? // Method receiver type (e.g., "Counter" for Counter::new)
}

///|
/// Represents a struct definition extracted from mbti
pub(all) struct StructDef {
  name : String
  visibility : String // "pub(all)", "pub", "priv", etc.
  raw_definition : String // The full struct definition as text
}

// =============================================================================
// Function Parsing
// =============================================================================

///|
/// Parse mbti content and extract public functions
pub fn parse_pub_funcs(
  content : String,
  filename : String,
) -> Array[PubFunc] raise {
  // Tokenize
  let lex_result = @lexer.tokens_from_string(
    name=filename,
    content,
    comment=false,
  )
  // Filter out newlines and comments
  let tokens = lex_result.tokens.filter(fn(triple) {
    not(triple.0 is (NEWLINE | COMMENT(_)))
  })
  // Parse
  let mbti = @mbti_parser.mbti(tokens, initial_pos=@basic.Position::{
    fname: filename,
    lnum: 1,
    bol: 0,
    cnum: 0,
  })
  // Extract function signatures
  let funcs : Array[PubFunc] = []
  for item in mbti.sigs {
    let (sig, _loc) = item
    match sig {
      Func(func_sig) => {
        let name = func_sig.name.name
        let type_name : String? = match func_sig.type_name {
          Some(tn) => Some(tn.name)
          None => None
        }
        funcs.push({ name, type_name })
      }
      _ => ()
    }
  }
  funcs
}

///|
/// Extract only standalone functions (not methods)
pub fn get_standalone_funcs(funcs : Array[PubFunc]) -> Array[String] {
  funcs.filter(fn(f) { f.type_name is None }).map(fn(f) { f.name })
}

///|
/// Extract methods for a specific type
pub fn get_methods_for_type(
  funcs : Array[PubFunc],
  type_name : String,
) -> Array[String] {
  funcs
  .filter(fn(f) {
    match f.type_name {
      Some(tn) => tn == type_name
      None => false
    }
  })
  .map(fn(f) { f.name })
}

// =============================================================================
// Struct Parsing
// =============================================================================

///|
/// Parse mbti content and extract struct definitions using simple string parsing
/// (The full parser doesn't handle `pub fn` format from moon info)
pub fn parse_struct_defs(
  content : String,
  _filename : String,
) -> Array[StructDef] {
  let structs : Array[StructDef] = []
  let lines = content.split("\n").to_array()
  let mut i = 0
  while i < lines.length() {
    let line = lines[i].to_string().trim(chars=" \t\n\r").to_string()
    // Look for struct definitions: pub(all) struct Name { or pub struct Name {
    if line.has_prefix("pub(all) struct ") || line.has_prefix("pub struct ") {
      let visibility = if line.has_prefix("pub(all)") {
        "pub(all)"
      } else {
        "pub"
      }
      // Extract struct name (safe: has_prefix check guarantees length)
      let after_struct = if visibility == "pub(all)" {
        line[16:].to_string() catch {
          _ => ""
        } // after "pub(all) struct "
      } else {
        line[11:].to_string() catch {
          _ => ""
        } // after "pub struct "
      }
      // Find name (up to space or {)
      let name = extract_name_until_delimiter(after_struct)
      // Extract full struct definition
      let raw_def = extract_struct_raw(content, name, visibility)
      structs.push({ name, visibility, raw_definition: raw_def })
    }
    i += 1
  }
  structs
}

///|
/// Extract only Props structs (names ending with "Props")
pub fn get_props_structs(structs : Array[StructDef]) -> Array[StructDef] {
  structs.filter(fn(s) { s.name.has_suffix("Props") })
}

// =============================================================================
// Internal Helpers
// =============================================================================

///|
/// Extract string until space or brace
fn extract_name_until_delimiter(s : String) -> String {
  let buf = StringBuilder::new()
  for c in s {
    if c == ' ' || c == '{' {
      break
    }
    buf.write_char(c)
  }
  buf.to_string()
}

///|
/// Extract raw struct definition from content by name
fn extract_struct_raw(
  content : String,
  name : String,
  visibility : String,
) -> String {
  // Look for pattern: visibility struct Name { ... }
  let vis_prefix = if visibility.length() > 0 { "\{visibility} " } else { "" }
  let pattern = "\{vis_prefix}struct \{name}"
  let lines = content.split("\n")
  let mut in_struct = false
  let mut brace_count = 0
  let buf = StringBuilder::new()
  for line in lines {
    let line_str = line.to_string()
    if not(in_struct) {
      if line_str.contains(pattern) {
        in_struct = true
        buf.write_string(line_str)
        buf.write_string("\n")
        // Count braces
        for c in line {
          if c == '{' {
            brace_count += 1
          } else if c == '}' {
            brace_count -= 1
          }
        }
        if brace_count == 0 {
          // Single line struct definition
          break
        }
      }
    } else {
      buf.write_string(line_str)
      buf.write_string("\n")
      for c in line {
        if c == '{' {
          brace_count += 1
        } else if c == '}' {
          brace_count -= 1
        }
      }
      if brace_count == 0 {
        break
      }
    }
  }
  buf.to_string().trim(chars=" \t\n\r").to_string()
}
