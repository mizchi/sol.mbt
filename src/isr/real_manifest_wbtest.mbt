// ISR Real Manifest Integration Test
//
// Tests ISR behavior using the actual generated manifest from docs build.
// This verifies the full integration from frontmatter → manifest → handler.

// =============================================================================
// Generated Manifest Simulation
// =============================================================================

///|
/// Recreate the manifest as generated by the build
fn create_real_manifest() -> ISRManifest {
  let pages : Map[String, ISRPageMeta] = {}

  // Exact pages from dist-docs/_luna/isr.json
  pages["/sol/isr-demo/"] = ISRPageMeta::{
    revalidate: 300,
    renderer: "markdown",
    source: "04_sol/isr-demo/index.md",
  }
  pages["/sol/isr-demo/hot/"] = ISRPageMeta::{
    revalidate: 300,
    renderer: "markdown",
    source: "04_sol/isr-demo/hot.md",
  }
  pages["/sol/isr-demo/warm/"] = ISRPageMeta::{
    revalidate: 120,
    renderer: "markdown",
    source: "04_sol/isr-demo/warm.md",
  }
  pages["/sol/isr-demo/cold/"] = ISRPageMeta::{
    revalidate: 60,
    renderer: "markdown",
    source: "04_sol/isr-demo/cold.md",
  }
  ISRManifest::{ version: 1, pages }
}

// =============================================================================
// Integration Tests
// =============================================================================

///|
test "real manifest: verify page count and paths" {
  let manifest = create_real_manifest()
  assert_eq(manifest.pages.length(), 4)
  assert_true(manifest.is_isr_page("/sol/isr-demo/"))
  assert_true(manifest.is_isr_page("/sol/isr-demo/hot/"))
  assert_true(manifest.is_isr_page("/sol/isr-demo/warm/"))
  assert_true(manifest.is_isr_page("/sol/isr-demo/cold/"))
  assert_false(manifest.is_isr_page("/sol/"))
  assert_false(manifest.is_isr_page("/luna/"))
}

///|
test "real manifest: verify TTL tiers" {
  let manifest = create_real_manifest()

  // Hot pages: 300s
  match manifest.get_page("/sol/isr-demo/") {
    Some(meta) => assert_eq(meta.revalidate, 300)
    None => fail("Expected hot page")
  }
  match manifest.get_page("/sol/isr-demo/hot/") {
    Some(meta) => assert_eq(meta.revalidate, 300)
    None => fail("Expected hot page")
  }

  // Warm page: 120s
  match manifest.get_page("/sol/isr-demo/warm/") {
    Some(meta) => assert_eq(meta.revalidate, 120)
    None => fail("Expected warm page")
  }

  // Cold page: 60s
  match manifest.get_page("/sol/isr-demo/cold/") {
    Some(meta) => assert_eq(meta.revalidate, 60)
    None => fail("Expected cold page")
  }
}

///|
test "real manifest: handler cache lifecycle" {
  let cache = MemoryCache::new()
  let manifest = create_real_manifest()
  let _handler = ISRHandler::{ cache, manifest, dist_dir: "/tmp/dist-docs" }
  let base_time = 1000000000L

  // Simulate initial cache population (as if CDN warmed)
  for path, meta in manifest.pages {
    let key = cache_key(path, [])
    let html = "<html><h1>" + path + "</h1><p>Generated content</p></html>"
    let entry = CacheEntry::new(html, base_time, meta.revalidate)
    ISRCache::put(cache, key, entry)
  }

  // Test at different time points

  // At 30s: all should be Fresh
  let t30 = base_time + 30000L
  for path, _ in manifest.pages {
    let key = cache_key(path, [])
    let status = check_status(ISRCache::get(cache, key), t30)
    match status {
      Fresh => ()
      _ => fail(path + " should be Fresh at 30s")
    }
  }

  // At 90s: cold should be Stale, others Fresh
  let t90 = base_time + 90000L
  let cold_status = check_status(
    ISRCache::get(cache, cache_key("/sol/isr-demo/cold/", [])),
    t90,
  )
  match cold_status {
    Stale => ()
    _ => fail("Cold page should be Stale at 90s")
  }
  let hot_status = check_status(
    ISRCache::get(cache, cache_key("/sol/isr-demo/hot/", [])),
    t90,
  )
  match hot_status {
    Fresh => ()
    _ => fail("Hot page should be Fresh at 90s")
  }

  // At 150s: cold and warm Stale, hot Fresh
  let t150 = base_time + 150000L
  let warm_status = check_status(
    ISRCache::get(cache, cache_key("/sol/isr-demo/warm/", [])),
    t150,
  )
  match warm_status {
    Stale => ()
    _ => fail("Warm page should be Stale at 150s")
  }
  let hot_status2 = check_status(
    ISRCache::get(cache, cache_key("/sol/isr-demo/hot/", [])),
    t150,
  )
  match hot_status2 {
    Fresh => ()
    _ => fail("Hot page should still be Fresh at 150s")
  }

  // At 350s: all should be Stale
  let t350 = base_time + 350000L
  for path, _ in manifest.pages {
    let key = cache_key(path, [])
    let status = check_status(ISRCache::get(cache, key), t350)
    match status {
      Stale => ()
      _ => fail(path + " should be Stale at 350s")
    }
  }
}

///|
test "real manifest: revalidation updates cache" {
  let cache = MemoryCache::new()
  let manifest = create_real_manifest()
  let handler = ISRHandler::{ cache, manifest, dist_dir: "/tmp/dist-docs" }
  let base_time = 1000000000L

  // Initial cache
  let cold_path = "/sol/isr-demo/cold/"
  let cold_key = cache_key(cold_path, [])
  ISRCache::put(
    cache,
    cold_key,
    CacheEntry::new("<html>v1</html>", base_time, 60),
  )

  // After 2 minutes: cold is Stale
  let t120 = base_time + 120000L
  let status1 = check_status(ISRCache::get(cache, cold_key), t120)
  match status1 {
    Stale => ()
    _ => fail("Cold page should be Stale at 120s")
  }

  // Simulate revalidation
  handler.update_cache(cold_path, "<html>v2 - revalidated</html>")

  // Verify updated content
  match ISRCache::get(cache, cold_key) {
    Some(e) => {
      assert_eq(e.html, "<html>v2 - revalidated</html>")
      assert_eq(e.revalidate, 60) // TTL preserved from manifest
    }
    None => fail("Expected updated cache entry")
  }
}

///|
test "real manifest: source path tracking" {
  let manifest = create_real_manifest()

  // Verify source paths are correctly tracked
  match manifest.get_page("/sol/isr-demo/") {
    Some(meta) => assert_eq(meta.source, "04_sol/isr-demo/index.md")
    None => fail("Expected page meta")
  }
  match manifest.get_page("/sol/isr-demo/cold/") {
    Some(meta) => assert_eq(meta.source, "04_sol/isr-demo/cold.md")
    None => fail("Expected page meta")
  }
}

///|
test "real manifest: fresh entry returns content without revalidation flag" {
  // This test verifies fresh entry behavior using check_status with fixed timestamps
  // Handler tests are affected by now_ms() returning 0 in test environment
  let cache = MemoryCache::new()
  let base_time = 1000000000L

  // Create fresh entry
  let hot_path = "/sol/isr-demo/hot/"
  let hot_key = cache_key(hot_path, [])
  ISRCache::put(
    cache,
    hot_key,
    CacheEntry::new("<html>Hot ISR Page content</html>", base_time, 300),
  )

  // Check at time before TTL (base + 150s < 300s TTL)
  let check_time = base_time + 150000L
  let cached = ISRCache::get(cache, hot_key)
  let status = check_status(cached, check_time)

  // Should be Fresh
  match status {
    Fresh => ()
    Stale => fail("Entry should be Fresh at 150s (TTL=300s)")
    Miss => fail("Entry should exist")
  }

  // Verify content
  match cached {
    Some(e) => assert_eq(e.html, "<html>Hot ISR Page content</html>")
    None => fail("Content should be available")
  }
}

///|
test "real manifest: stale entry detected by check_status" {
  // This test verifies the core ISR logic without depending on handler
  // which uses now_ms() that may not work correctly in test environment
  let cache = MemoryCache::new()
  let base_time = 1000000000L

  // Create stale entry
  let cold_path = "/sol/isr-demo/cold/"
  let cold_key = cache_key(cold_path, [])
  let entry = CacheEntry::new("<html>Stale cold content</html>", base_time, 60)
  ISRCache::put(cache, cold_key, entry)

  // Check at time after TTL (base + 120s = after 60s TTL)
  let check_time = base_time + 120000L
  let cached = ISRCache::get(cache, cold_key)
  let status = check_status(cached, check_time)

  // Should be Stale
  match status {
    Stale => ()
    Fresh => fail("Entry should be Stale at 120s (TTL=60s)")
    Miss => fail("Entry should exist")
  }

  // Verify content is still available
  match cached {
    Some(e) => assert_eq(e.html, "<html>Stale cold content</html>")
    None => fail("Content should be available even when stale")
  }
}

///|
test "real manifest: non-ISR page returns None" {
  let cache = MemoryCache::new()
  let manifest = create_real_manifest()
  let handler = ISRHandler::{ cache, manifest, dist_dir: "/tmp/dist-docs" }

  // Request a page that's not in ISR manifest
  let (html, needs_revalidation) = handler.handle("/luna/")

  // Should return None (not an ISR page)
  assert_true(html is None)
  assert_false(needs_revalidation)
}
