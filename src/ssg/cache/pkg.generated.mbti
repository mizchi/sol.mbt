// Generated using `moon info`, DON'T EDIT IT
package "mizchi/luna/sol/ssg/cache"

import(
  "mizchi/luna/sol/adapters/fs"
  "mizchi/luna/sol/core/env"
  "mizchi/luna/sol/ssg"
)

// Values
pub let cache_format_version : Int

pub fn[P : BuildStateProvider] check_build_state(P, String, String, (String) -> BuildManifest?) -> BuildStateCheck

pub fn check_local_build_state(@ssg.SsgConfig, String, String) -> BuildStateCheck

pub fn compute_assets_hash(String) -> String

pub fn compute_config_hash(@ssg.SsgConfig) -> String

pub fn compute_content_hash(String, String, Array[String]) -> String

pub fn compute_page_hash(String, String, String) -> String

pub fn fnv1a(String) -> String

pub fn fnv1a_64(String) -> String

pub fn get_current_timestamp() -> String

pub fn hash_content(String, String) -> String

pub fn hash_strings(Array[String]) -> String

pub fn save_manifest(String, @ssg.SsgConfig, String) -> Unit

pub let sol_version : String

// Errors

// Types and methods
pub(all) struct BuildManifest {
  tool_version : String
  config_hash : String
  content_state : String
  built_at : String
}
pub fn BuildManifest::from_json(String) -> Self?
pub fn BuildManifest::matches(Self, String, String) -> Bool
pub fn BuildManifest::new(tool_version~ : String, config_hash~ : String, content_state~ : String, built_at~ : String) -> Self
pub fn BuildManifest::to_json(Self) -> String

pub(all) enum BuildStateCheck {
  UpToDate(String)
  NeedsRebuild
  NoPreviousBuild
}
pub fn BuildStateCheck::is_up_to_date(Self) -> Bool

pub(all) struct CacheEntry {
  key : String
  value : String
  cached_at : String
  ttl : Int
}
pub fn CacheEntry::new(key~ : String, value~ : String, cached_at? : String, ttl? : Int) -> Self

pub(all) struct CacheManager {
  cache : DiskCache[@fs.NodeFsAdapter]
  enabled : Bool
}
pub fn CacheManager::clear(Self) -> Unit
pub fn CacheManager::get(Self, String, String) -> String?
pub fn CacheManager::new(String, @ssg.SsgConfig, enabled? : Bool) -> Self
pub fn CacheManager::save(Self) -> Unit
pub fn CacheManager::set(Self, String, String, String) -> Unit
pub fn CacheManager::stats(Self) -> (Int, Int)
pub fn[F : @env.FileSystem] CacheManager::with_fs(F, String, String, enabled? : Bool) -> DiskCache[F]

pub(all) struct CacheMeta {
  version : Int
  config_hash : String
  entries : Map[String, EntryMeta]
}
pub fn CacheMeta::new(config_hash? : String) -> Self

pub(all) enum CacheStatus {
  Hit(String)
  Miss
  Stale(String)
  Invalid
}
pub fn CacheStatus::is_hit(Self) -> Bool
pub fn CacheStatus::value(Self) -> String?

pub(all) struct DiskCache[F] {
  fs : F
  cache_dir : String
  meta : CacheMeta
  enabled : Bool
}
pub fn[F : @env.FileSystem] DiskCache::clear(Self[F]) -> Unit
pub fn[F : @env.FileSystem] DiskCache::get(Self[F], String) -> CacheStatus
pub fn[F : @env.FileSystem] DiskCache::get_with_hash(Self[F], String, String) -> CacheStatus
pub fn[F : @env.FileSystem] DiskCache::new(F, cache_dir~ : String, config_hash? : String, enabled? : Bool) -> Self[F]
pub fn[F : @env.FileSystem] DiskCache::remove(Self[F], String) -> Unit
pub fn[F : @env.FileSystem] DiskCache::save(Self[F]) -> Unit
pub fn[F : @env.FileSystem] DiskCache::set(Self[F], String, String, String, ttl? : Int) -> Unit
pub fn[F : @env.FileSystem] DiskCache::stats(Self[F]) -> (Int, Int)

pub(all) struct EntryMeta {
  content_hash : String
  cached_at : String
  ttl : Int
}

pub(all) struct LocalFileProvider {
  docs_dir : String
  cwd : String
  exclude : Array[String]
  mut cached_state : String?
}
pub fn LocalFileProvider::new(String, String, Array[String]) -> Self
pub impl BuildStateProvider for LocalFileProvider

// Type aliases

// Traits
pub(open) trait BuildStateProvider {
  get_content_state(Self) -> String
  describe_state(Self) -> String
}

